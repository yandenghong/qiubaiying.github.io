---
layout:     post
title:      Redis为什么没有使用C语言自带的字符串
date:       2019-04-16
author:     yandenghong
header-img: img/post-bg-ocean.png
catalog: true
tags:
    - 数据结构
    - redis
---

## 前言 
最近在深度研究redis, 源码中看到redis中使用自定义的一种结构`sdshdr`(SDS，Simple Dynamic String, 简单动态字符串)保存字符串，遂决定研究一下
为什么没有用C语言自带的字符串。

## 正文
首先看下SDS字符串结构体:
```c
struct sdshdr { 
    int len; 
    int free; 
    char buf[]; 
} 
```
> * len: 存储字符串长度, 标志SDS字符串结束。(在C语言中"\0"标志C字符串结束)
> * buf[]: 存储实际内容
> * free: buf中空闲空间的长度

C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。
>内存缓冲区溢出:当缓冲区溢出时，过剩的信息覆盖的是计算机内存中以前的内容。
>
>内存泄露：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃.

redis通常使用于高并发且数据频繁修改的场景，因此其字符串肯定是频繁修改的。
如果使用C内置的字符串，则频繁的重新分配内存会带来大量的性能消耗。

而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：

* 空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
分配规则如下：如果对 SDS 修改后，len 的长度小于 1M，那么程序将分配和 len 相同长度的未使用空间。
* 惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）

另外， 因为C字符串不记录字符串长度，获取字符串长度需要遍历整个字符串到"\0"结束，时间复杂度O(n)；SDS获取字符串长度的时间复杂度只有O(1);

除此之外，SDS还能存储二进制数据。

## 总结
SDS字符串与C字符串相比:
* 获取字符串长度需要的时间更短
* 避免了内存缓冲区溢出
* 减少了字符串修改时进行内存重新分配的次数
* 二进制安全
