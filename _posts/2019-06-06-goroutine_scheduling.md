---
layout:     post
title:      Goroutine调度原理
date:       2019-06-06
author:     yandenghong
header-img: img/post-bg-universe.png
catalog: true
tags:
    - Golang
---

goroutine即协程，由与操作系统核数相等数目的线程运行，并由go自己的调度器调度。

其调度与操作系统线程调度相似但又有部分不同。

## 操作系统的线程调度

OS线程会被操作系统内核调度。每几毫秒,一个硬件计时器会中断处理器,这会调用一个叫作scheduler
的内核函数。这个函数会挂起当前执行的线程并保存内存中它的寄存器内容,检查线程列表并决定下一
次哪个线程可以被运行,并从内存中恢复该线程的寄存器信息,然后恢复执行该线程的现场并开始执行
线程。因为操作系统线程是被内核所调度,所以从一个线程向另一个切换需要完整的上下文切换,
也就是说,保存一个用户线程的状态到内存,恢复另一个线程的到寄存器,然后更新调度器的数据结
构。这几步操作很慢,因为其局部性很差需要几次内存访问,并且会增加运行的cpu周期。

## GPM调度模型
![](/img/GPM.png)

## Goroutine调度
Go使用了自己的调度器，其工作和内核的调度是相似的,但是这个调度器只关
注单独的Go程序中的goroutine。

和操作系统的线程调度不同的是,**Go调度器并不是用一个硬件定时器而是被Go语言本身进行调度
的**。例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻塞时,调度器会使其进
入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个goroutine。因为因为这种调度方式不
需要进入内核的上下文,所以重新调度一个goroutine比调度一个线程代价要低得多。

## GOMAXPROCS
Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其
默认的值是运行机器上的CPU的核心数,所以在一个有8个核心的机器上时,调度器一次会在8个OS线程上
去调度GO代码。
