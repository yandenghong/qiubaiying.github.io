---
layout:     post
title:      缓存穿透、缓存雪崩解决方案指北
date:       2020-01-07
author:     yandenghong
header-img: img/post-moon.png
catalog: true
tags:
    - Redis
    - 缓存
    - 缓存穿透
    - 缓存雪崩
---
## 前言

在构建后端服务的过程中，我们为了提升服务的吞吐量，减少不必要的服务器开销，通常都会在用户和数据库之间增加一层缓存层。

基本工作流程: 请求到来先查找缓存，缓存中找不到再去数据库中查找，如果数据库中查到了，再写回缓存，同时，当数据库中写入时，也写入缓存。

然而，在一个系统中增加一个模块，往往会带来新的问题。增加了缓存层，虽然带来了性能的提升，但也存在如下隐患。

## 缓存穿透

用户频繁请求缓存中不存在，数据库中也不存在的数据，导致数据库执行大量无意义的查询，占用服务器资源。

解决方案:
```text
1.缓存空结果。当数据库中查询为空后，将空结果也写入到缓存，这样下次再请求，缓存直接返回空。（无需担心如果后来数据库中有了该数据，缓存不一致的问题，因为写入时会将缓存中原来的空值覆盖。）

2.限制请求频率。比较简单的实现方式是用redis,ip为key,访问次数为value，并设置过期时间，在过期时间内统计同一个ip的访问次数，超过规定次数即拒绝服务。

3.布隆过滤器。将所有有效的key加入过滤器中，每次请求过来先经过布隆过滤器，如果请求的数据不存在，则拒绝服务。
```

另外一个方法是加互斥锁，缓存中不存在时，先抢锁，获得锁的去请求数据库，没得到锁的，休眠一段时间重试。但这个方法会大大降低系统吞吐量，不推荐使用。

# 缓存雪崩

缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，数据库因此发生异常。

解决方案:
```text
1.给缓存过期时间设置随机值，避免集体失效。
2.双缓存。缓存A设置过期时间，缓存B不设置，数据库写入时同时在双缓存中写入。缓存A中查询不到先去缓存B查询。
```

此问题也可以使用互斥锁，但同样会降低吞吐量，不推荐使用。

